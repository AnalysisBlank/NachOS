2014年10月11日 17时52分23秒 
运行过程：
。。。
构建自动计分器
	系统自带的构建对象完成

1创建TCB（TCB的介绍可以参看代码，做了一些简单的翻译）
	1-1TCB的start：先做简单的判断（运行线程的个数等）
	1-2添加线程到虚拟的线程池，根据是否是第一个TCB开启两个分支
	1-3 如果是第一次创建TCB，直接保存到javaThread（就是与每个TCB对应的线程），然后开始threadroot

* threadroot()方法
如果是第一个TCB调用的，直接保存当前线程，并设置running状态为true就可以，
如果不是第一个TCB

	如果不是第一个TCB
	1-4

然后运行target线程。


在TCB里面New的runnable是自动计分器开始


Config类是对config文件的读入处理，通过lib的constructObject来实现Kernel的替换。
在pro1中，真正的kernel是ThreadedKernel。

Lib只是一些函数的集合，都集中在一块，做成库。方便调用。


2014年10月13日 22时01分48秒 
autograder那里在构建之后，作为实参传入的时候（start），进行了大量的操作，

threadedkernel里面new kthread的时候，传入一个null有什么用？


2-1autograde.start
	2-1-1大量的初始化工作：
		2-1-1-1kernel的初始化：
			new KThread(null);检测到是第一个Kthread，那么还会创建一个闲逛线程。
*创建闲逛线程：
new KThread的时候传入的是new Runnable() {
	    public void run() { while (true) yield(); }
	}，带参数的构造函数则调用无参构造函数，然后new一个TCB
然后是闲逛线程的fork：
	关中断；
	进入TCB的start模块：

	

		2-1-1-2 autograder的run
			2-1-1-2-1kernel.selfTest();即ThreadedKernel的selfTest，三个selfTest，
		

